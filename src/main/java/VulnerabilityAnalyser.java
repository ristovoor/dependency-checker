import com.google.gson.*;
import com.google.gson.reflect.TypeToken;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

public class VulnerabilityAnalyser {
    public VulnerabilityDictionary vulnerabilities; // Define it here
    private URL url;
    private URL folder;
    private boolean changed = false;
    public static Settings settings;

    public VulnerabilityAnalyser(Settings settings) {
        this.settings = settings;
        try {
            this.folder = settings.homeFolder.toURI().toURL();
            this.url = new URL(folder, "vulnerabilities.json");

            Path path = Paths.get(url.getPath());
            byte[] data = Files.readAllBytes(path);
            String jsonData = new String(data);
            Gson gson = new GsonBuilder().registerTypeAdapter(Date.class, new DateDeserializer())
                    .create();
            VulnerabilityDictionary decoded;
            try {
                decoded = gson.fromJson(jsonData, VulnerabilityDictionary.class);
            } catch (JsonSyntaxException e) {
                decoded = new VulnerabilityDictionary(new Date());
            }
            vulnerabilities = decoded;
        } catch (MalformedURLException e) {
            LoggerHelper.log(LogLevel.ERROR, "Error creating URL: " + e.getMessage());
        } catch (IOException e) {
            vulnerabilities = new VulnerabilityDictionary(new Date());
        } catch (Exception e) {
            LoggerHelper.log(LogLevel.ERROR, "Error reading file: " + e.getMessage());
        }
    }

    class DateDeserializer implements JsonDeserializer<Date> {
        @Override
        public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
            // Parse Unix timestamp from JSON string
            String dateString = json.getAsString();

            // Convert Unix timestamp string to long
            double unixTimestamp = Double.parseDouble(dateString);

            // Convert Unix timestamp to Date object
            return new Date((long) (unixTimestamp * 1000)); // Multiply by 1000 to convert seconds to milliseconds
        }
    }

    public List<CVEData> queryVulnerabilitiesFor(String cpe) {
        LoggerHelper.log(LogLevel.DEBUG, "[*] Finding vulnerabilities for cpe: " + cpe);

        if (this.vulnerabilities.dictionary.containsKey(cpe)) {
            VulnerabilityData existingCVEData = this.vulnerabilities.dictionary.get(cpe);
            if (shouldUpdate(existingCVEData)) {
                LoggerHelper.log(LogLevel.DEBUG, "[i] Existing data, but should update.");
                List<CVEData> cveList = query(cpe);
                existingCVEData.vulnerabilities = cveList;
                existingCVEData.lastUpdated = new Date();
                this.vulnerabilities.dictionary.put(cpe, existingCVEData);
                this.changed = true;
                return cveList;
            } else {
                LoggerHelper.log(LogLevel.DEBUG, "[i] Found existing data");
                return existingCVEData.vulnerabilities;
            }
        } else {
            LoggerHelper.log(LogLevel.DEBUG, "[i] No existing data found.");
            List<CVEData> cveList = query(cpe);
            this.vulnerabilities.dictionary.put(cpe, new VulnerabilityData(cveList));
            this.changed = true;
            return cveList;
        }
    }

    public List<CVEData> query(String cpe) {
        List<CVEData> cveList = new ArrayList<>();

        String urlString = "https://services.nvd.nist.gov/rest/json/cves/2.0?virtualMatchString=" + cpe + "&resultsPerPage=2000";

        try {
            URL url = new URL(urlString);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("GET");

            // Program waits 6 seconds between requests to avoid exceeding the NVD API limit
            Thread.sleep(6000);

            int responseCode = connection.getResponseCode();
            if (responseCode == HttpURLConnection.HTTP_OK) {
                // Read the response data
                // Assuming you have a method readResponseData() to handle this
                String responseData = readResponseData(connection.getInputStream());

                // Parse JSON response
                Map<String, Object> jsonResponse = parseJsonResponse(responseData);

                if (jsonResponse != null) {
                    Double resultsPerPage = (Double) jsonResponse.get("resultsPerPage");
                    Double totalResults = (Double) jsonResponse.get("totalResults");

                    if (totalResults > 0) {
                        //Map<String, Object> result = (Map<String, Object>) jsonResponse.get("vulnerabilities");
                        List<Map<String, Object>> result = (List<Map<String, Object>>) jsonResponse.get("vulnerabilities");

                        if (result != null) {
                            for (Map<String, Object> cve : result) {
                                CVEData cveData = new CVEData(cve);
                                cveList.add(cveData);
                            }
                            /*
                            List<Map<String, Object>> cves = (List<Map<String, Object>>) result.get("CVE_Items");

                            if (cves != null) {
                                for (Map<String, Object> cve : cves) {
                                    CVEData cveData = new CVEData(cve);
                                    cveList.add(cveData);
                                }
                            } else {
                                LoggerHelper.log(LogLevel.ERROR,"[!] CVE object not found");
                            }

                             */
                        }
                    }
                } else {
                    LoggerHelper.log(LogLevel.ERROR, "[!] No JSON response");
                }
            } else {
                LoggerHelper.log(LogLevel.ERROR, "[!] Failed to fetch data. Response code: " + responseCode);
            }
        } catch (IOException | InterruptedException e) {
            LoggerHelper.log(LogLevel.ERROR, "[!] Error: " + e.getMessage());
        }
        return cveList;
    }

    private String readResponseData(InputStream inputStream) throws IOException {
        StringBuilder responseData = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
            String line;
            while ((line = reader.readLine()) != null) {
                responseData.append(line);
            }
        }
        return responseData.toString();
    }

    private Map<String, Object> parseJsonResponse(String responseData) {
        // Assuming you are using Gson library for JSON parsing
        Gson gson = new Gson();
        Type type = new TypeToken<Map<String, Object>>() {
        }.getType();
        return gson.fromJson(responseData, type);
    }

    public boolean shouldUpdate(VulnerabilityData data) {
        LoggerHelper.log(LogLevel.INFO, "[i] Vulnerability data last updated: " + data.lastUpdated.toString());

        if (VulnerabilityAnalyser.settings.vulnerabilityTimeInterval != null) {
            // check if time since last updated is larger than the allowed timeinterval for updates
            long currentTime = new Date().getTime();
            long lastUpdatedTime = data.lastUpdated.getTime();
            long timeInterval = VulnerabilityAnalyser.settings.vulnerabilityTimeInterval;

            if ((currentTime - lastUpdatedTime) > timeInterval) {
                LoggerHelper.log(LogLevel.INFO, "[i] Will update vulnerability data");
                return true;
            }
        }

        LoggerHelper.log(LogLevel.DEBUG, "[i] No update for vulnerability data");
        return false;
    }
}

class VulnerabilityDictionary {
    public Map<String, VulnerabilityData> dictionary;

    public VulnerabilityDictionary(Date lastUpdated) {
        this.dictionary = new HashMap<>();
    }
}

class VulnerabilityData {
    public Date lastUpdated;
    public List<CVEData> vulnerabilities;

    public VulnerabilityData(List<CVEData> vulnerabilities) {
        this.lastUpdated = new Date();
        this.vulnerabilities = vulnerabilities;
    }
}

class CVEData {
    public String publishedDate;
    public String lastModifiedDate;
    public Configuration configuration;
    public Impact impact;
    public CVE cve; // required value

    public CVEData(Map<String, Object> fromJson) {


        Map<String, Object> cveJson = (Map<String, Object>) fromJson.get("cve");
        if (cveJson != null) {
            this.cve = new CVE(cveJson);
        }
        this.publishedDate = (String) cveJson.get("published");
        this.lastModifiedDate = (String) cveJson.get("lastModified");

        this.configuration = new Configuration((List<Map<String, Object>>) cveJson.get("configurations"));


        Map<String, Object> impactJson = (Map<String, Object>) fromJson.get("impact");
        if (impactJson != null) {
            this.impact = new Impact(impactJson);
        }

    }
}

class CVE {
    public String description;
    public String problemType;
    public List<Reference> references = new ArrayList<>();
    public String cveId;

    public CVE(Map<String, Object> fromJson) {
        if (fromJson.containsKey("id")) {
            this.cveId = (String) fromJson.get("id");
        }

        if (fromJson.containsKey("descriptions")) {
            List<Map<String, Object>> descriptionData = (List<Map<String, Object>>) fromJson.get("descriptions");
            this.description = "";
            for (Map<String, Object> description : descriptionData) {
                String language = (String) description.get("lang");
                String value = (String) description.get("value");
                if (this.description.isEmpty()) {
                    this.description = language + ": " + value;
                } else {
                    this.description += ", " + language + ": " + value;
                }
            }
        }

        if (fromJson.containsKey("problemtype")) {
            Map<String, Object> problemTypeObject = (Map<String, Object>) fromJson.get("problemtype");
            if (problemTypeObject.containsKey("problemtype_data")) {
                List<Map<String, Object>> problemTypeData = (List<Map<String, Object>>) problemTypeObject.get("problemtype_data");
                this.problemType = "";
                for (Map<String, Object> problemType : problemTypeData) {
                    if (problemType.containsKey("description")) {
                        List<Map<String, Object>> problemTypeDescriptions = (List<Map<String, Object>>) problemType.get("description");
                        for (Map<String, Object> problemTypeDescription : problemTypeDescriptions) {
                            String language = (String) problemTypeDescription.get("lang");
                            String value = (String) problemTypeDescription.get("value");
                            if (this.problemType.isEmpty()) {
                                this.problemType = language + ": " + value;
                            } else {
                                this.problemType += ", " + language + ": " + value;
                            }
                        }
                    }
                }
            }
        }

        if (fromJson.containsKey("references")) {
            List<Map<String, Object>> referencesObject = (List<Map<String, Object>>) fromJson.get("references");
            for (Map<String, Object> obj : referencesObject) {
                if (obj.containsKey("reference_data")) {
                    List<Map<String, Object>> referencesData = (List<Map<String, Object>>) obj.get("reference_data");
                    for (Map<String, Object> reference : referencesData) {
                        this.references.add(new Reference(reference));
                    }
                }
            }

        }
    }
}

class Reference {
    public String name;
    public String refSource;
    public List<String> tags;
    public String url; // required

    public Reference(Map<String, Object> fromJson) {
        this.name = (String) fromJson.get("name");
        this.refSource = (String) fromJson.get("source");
        this.url = (String) fromJson.get("url");

        Object tagsObj = fromJson.get("tags");
        if (tagsObj instanceof List<?>) {
            this.tags = (List<String>) tagsObj;
        } else {
            this.tags = List.of();
        }
    }
}

class BaseMetric {
    public String attackComplexity;        //v3,   v2 (accessComplexity)
    public String attackVector;            //v3,   v2
    public String authentication;          //      v2
    public String availabilityImpact;      //v3,   v2
    public Float baseScore;                //v3,   v2
    public String baseSeverity;            //v3,   v2 (severity)
    public String confidentialityImpact;   //v3,   v2
    public String integrityImpact;         //v3,   v2
    public String privilegesRequired;      //v3    (== authentication??)
    public String scope;                   //v3
    public String userInteractionRequired; //v3 (userInteraction) ,   v2
    public String vectorString;            //v3,   v2
    public Float exploitabilityScore;      //v3,   v2
    public Float impactScore;              //v3,   v2
    public MetricVersion version;

    public enum MetricVersion {
        V2,
        V3
    }

    public void BaseMetric1(Map<String, Object> fromV3Json) {
        Map<String, Object> cvssV3 = (Map<String, Object>) fromV3Json.get("cvssV3");
        if (cvssV3 != null) {
            this.attackComplexity = (String) cvssV3.get("attackComplexity");
            this.attackVector = (String) cvssV3.get("attackVector");
            this.availabilityImpact = (String) cvssV3.get("availabilityImpact");
            this.baseScore = (Float) cvssV3.get("baseScore");
            this.baseSeverity = (String) cvssV3.get("baseSeverity");
            this.confidentialityImpact = (String) cvssV3.get("confidentialityImpact");
            this.integrityImpact = (String) cvssV3.get("integrityImpact");
            this.privilegesRequired = (String) cvssV3.get("privilegesRequired");
            this.scope = (String) cvssV3.get("scope");
            this.userInteractionRequired = (String) cvssV3.get("userInteraction");
            this.vectorString = (String) cvssV3.get("vectorString");
        }

        this.exploitabilityScore = (Float) fromV3Json.get("exploitabilityScore");
        this.impactScore = (Float) fromV3Json.get("impactScore");
        this.version = MetricVersion.V3;
    }

    public void BaseMetric2(Map<String, Object> fromV2Json) {
        Map<String, Object> cvssV2 = (Map<String, Object>) fromV2Json.get("cvssV2");
        if (cvssV2 != null) {
            this.attackComplexity = (String) cvssV2.get("accessComplexity");
            this.attackVector = (String) cvssV2.get("accessVector");
            this.authentication = (String) cvssV2.get("authentication");
            this.availabilityImpact = (String) cvssV2.get("availabilityImpact");
            this.baseScore = (Float) cvssV2.get("baseScore");
            this.confidentialityImpact = (String) cvssV2.get("confidentialityImpact");
            this.integrityImpact = (String) cvssV2.get("integrityImpact");
            this.vectorString = (String) cvssV2.get("vectorString");
        }

        this.exploitabilityScore = (Float) fromV2Json.get("exploitabilityScore");
        this.impactScore = (Float) fromV2Json.get("impactScore");
        //this.obtainAllPrivilege = (Boolean) fromV2Json.get("obtainAllPrivilege");
        //this.obtainOtherPrivilege = (Boolean) fromV2Json.get("obtainOtherPrivilege");
        //this.obtainUserPrivilege = (Boolean) fromV2Json.get("obtainUserPrivilege");
        this.baseSeverity = (String) fromV2Json.get("severity");
        this.userInteractionRequired = String.valueOf(fromV2Json.get("userInteractionRequired"));
        this.version = MetricVersion.V2;
    }
}

class Impact {
    public BaseMetric baseMetricV3;
    public BaseMetric baseMetricV2;

    public Impact(Map<String, Object> fromJson) {
        if (fromJson.containsKey("baseMetricV2")) {
            Map<String, Object> baseMetricV2Map = (Map<String, Object>) fromJson.get("baseMetricV2");
            //this.baseMetricV2 = new BaseMetric(baseMetricV2Map);
        }

        if (fromJson.containsKey("baseMetricV3")) {
            Map<String, Object> baseMetricV3Map = (Map<String, Object>) fromJson.get("baseMetricV3");
            // this.baseMetricV3 = new BaseMetric(baseMetricV3Map);
        }
    }
}

class CPEMatch {
    public String originalcpeString;
    public String cpeString; // required
    public String versionEndExcluding;
    public String versionEndIncluding;
    public String versionStartIncluding;
    public String versionStartExcluding;
    public String exactVersion;
    public boolean vulnerable; // required

    public CPEMatch(Map<String, Object> fromJson) {
        String cpe23Uri = (String) fromJson.get("criteria");
        if (cpe23Uri != null && !cpe23Uri.isEmpty()) {
            this.originalcpeString = cpe23Uri;
            String[] components = cpe23Uri.split(":");
            // cpe:2.3:a:libevent_project:libevent:*:beta:*:*:*:*:*:*
            // cpe:2.3:a:google:protobuf:2.4.1:*:*:*:*:*:*:*
            String potentialVersion = components[5];
            if (!potentialVersion.isEmpty() && !potentialVersion.equals("*") && !potentialVersion.equals("-")) {
                this.exactVersion = potentialVersion;
            }
            components[5] = ""; // version number if specified
            components[6] = ""; // if beta specified
            this.cpeString = String.join(":", components);
        } else {
            this.cpeString = "Not found"; // should never happen
            this.originalcpeString = "Not found"; // should never happen
        }

        this.vulnerable = (boolean) fromJson.getOrDefault("vulnerable", false);

        this.versionEndExcluding = (String) fromJson.get("versionEndExcluding");
        this.versionEndIncluding = (String) fromJson.get("versionEndIncluding");
        this.versionStartIncluding = (String) fromJson.get("versionStartIncluding");
        this.versionStartExcluding = (String) fromJson.get("versionStartExcluding");
    }

    public String getVersionString() {
        StringBuilder stringBuilder = new StringBuilder();
        if (versionEndExcluding != null) {
            stringBuilder.append("endExcluding: ").append(versionEndExcluding).append(" ");
        }

        if (versionEndIncluding != null) {
            stringBuilder.append("endIncluding: ").append(versionEndIncluding).append(" ");
        }

        if (versionStartExcluding != null) {
            stringBuilder.append("startExcluding: ").append(versionStartExcluding).append(" ");
        }

        if (versionStartIncluding != null) {
            stringBuilder.append("startIncluding: ").append(versionStartIncluding).append(" ");
        }

        return stringBuilder.toString();
    }
}

class Node {
    private List<Node> children = new ArrayList<>();
    private List<CPEMatch> cpeMatch = new ArrayList<>();
    private String operatorString;

    public Node(Map<String, Object> fromJson) {
        List<Map<String,Object>> temp = (List<Map<String,Object>>) fromJson.get("nodes");
        for(Map<String,Object> el : temp){
            if (el.containsKey("children")) {
                List<Map<String, Object>> childrenJson = (List<Map<String, Object>>) el.get("children");
                for (Map<String, Object> child : childrenJson) {
                    children.add(new Node(child));
                }
            }

            if (el.containsKey("cpeMatch")) {
                List<Map<String, Object>> cpeMatchJson = (List<Map<String, Object>>) el.get("cpeMatch");
                for (Map<String, Object> match : cpeMatchJson) {
                    cpeMatch.add(new CPEMatch(match));
                }
            }

            if (el.containsKey("operator")) {
                operatorString = (String) el.get("operator");
            } else {
                operatorString = "--"; // should not happen
            }
        }
    }

    public List<CPEMatch> getAffectedVersions() {
        List<CPEMatch> list = new ArrayList<>();
        for (Node node : children) {
            list.addAll(node.getAffectedVersions());
        }

        list.addAll(cpeMatch);

        return list;
    }
}

class Configuration {
    public List<Node> nodes = new ArrayList<>();

    public Configuration(List<Map<String, Object>> fromJson) {
        for (Map<String, Object> nodeJson : fromJson) {
            nodes.add(new Node(nodeJson));
        }
    }

    public List<CPEMatch> getAffectedVersions() {
        List<CPEMatch> list = new ArrayList<>();
        for (Node node : nodes) {
            list.addAll(node.getAffectedVersions());
        }
        return list;
    }
}
